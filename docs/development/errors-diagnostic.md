# Errors and Diagnostic

ONNC introduces errors, exceptions, and runtime information for development, debugging and the diagnostic system.

## Errors

There are two kinds of errors in ONNC: system-defined errors in major and developer-defined errors in minor. The error can be used for the program's action, debugging, or the diagnostic system.

All error codes generated by Linux, macOS or Windows are listed in [`<Support/ErrorCode.h>`](../../include/onnc/Support/ErrorCode.h), which defines the `SystemError` class, the standard error handler in ONNC, and are translated from the original code to ONNC's code.

Errors caused by the operating system cover most cases, such as `EBUSY`, `ENOSYS` or `EFAULT`. While several errors resulted by the ONNC compiler, for example, `Success`, `NotStartedYet`, or `UnknownError`, are also defined in `ErrorCode.h`.

For instance:

```cpp
#include <onnc/Support/ErrorCode.h>
#include <onnc/Support/IOStream.h>
#include <errno.h>

using namespace onnc;

int fd = open("/", O_WRONLY);
SystemError err(errno); // get a copy from `errno`
if (!err.isGood())
  errs() << err; // permission deny
```

In this example, the `SystemError` type object `err` copies, translates, and stores the value of `errno`, a global variable representing error code given by the system.

`errs()` is a reference to a OStream for standard error defined in [`<onnc/Support/IOStream.h>`](../../include/onnc/Support/IOStream.h).

## Diagnostic

The diagnostic system powers the capability for developers to find the problems. According to the severity of the information, there are seven levels defined in [`include <onnc/Diagnostic/MsgHandling.h>`](../../include/onnc/Diagnostic/MsgHandling.h)

| Mode        | Handler           | Meaning  |
| ------------- |:-------------:| -----|
| normal | unreachable  | Errors that should never happen|
| normal | fatal | Egregious errors that break the program|
| normal |  error | Normal errors that the program keep going on until it cannot |
| verbose | warning | warnings |
| engineering verbose | debug | Information for debug mode |
| engineering verbose | note | Less important information for debug mode |
| noisy verbose | ignore | any verbose messages |

The example shows how to use the handlers:

```cpp
#include <onnc/Diagnostic/MsgHandling.h>
using namespace onnc;

if (I got a serious problem)
  fatal(fatal_open_folder) << "this folder" << 2;
```

The format is:

```text
handler(ErrorID) << mesg0 << mesg1 << ... << mesg9;
```

Note that there are **at most** `10` messages that can pass to a handler; otherwise ONNC shows the warning and breaks.

ONNC supports the following types for messages:

| Type | Definition |
| ---- |------------|
| bool/int32_t/int64_t | Support/DataTypes |
| char*/std::string/onnc::StringRef | ADT/StringRef.h |
| Path | Support/Path.h |
| onnc::SystemError | Support/ErrorCode.h |

### Registering a New Diagnostic Error

To register a new diagnostic error, go to [`include/onnc/Diagnostics/DiagCommonKinds.inc`](../../include/onnc/Diagnostic/DiagCommonKinds.inc) and create a new `DIAG`.

`DIAG`'s format is `DIAG(error name, error level, message)` where `message` is a string with placeholders `%N`, starts from `%0`, `%1` and so on, that receives inputs.

For example, if a new error, `numerical_type_error`, is going to be registered. The line should be added to the end of the file `DiagCommonKinds.inc`:

```inc
DIAG(numerical_type_error, Fatal, "The number is %0 type where it should be %1 type.")
```

Use the error message in code:

```cpp
#include <onnc/Diagnostic/MsgHandling.h>
onnc::fatal(numerical_error) << "int" << "float";
```

Note that `"int"` is passed to `%0`, and `"float"` is for `%1`.

## Usage

Via the number of the argument `-v`, ONNC outputs the log in different modes.

```log
$ onnc -h # normal mode
$ onnc -h -v # verbose mode
$ onnc -h -v -v -v # engineering mode
$ onnc -h -v -v -v -v -v # noisy mode
```
